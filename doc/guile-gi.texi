\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename guile-gi.info
@settitle Guile GI
@c %**end of header

@copying
Copyright @copyright{} 2018 Michael L. Gran
@end copying

@titlepage
@title Guile GI
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Preface, (dir), (dir)
@top Guile GI

This manual is for Guile GI.
@end ifnottex

@menu
* Preface::
* Getting Started::
* Tutorials::
* Reference Guide::
* Further Resources and Contact Info::
* Index::

@detailmenu
 --- The Detailed Node Listing ---

Getting Started

* Installation::
* Sample Applications::

Sample Applications

* Example 1::

Tutorials

* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::

Reference Guide

* gi module::
* gobject module::

@end detailmenu
@end menu

@node Preface, Getting Started, Top, Top
@unnumbered Preface
Guile GI is a Guile package that provides for GObject based libraries
such as GTK+, GLib, WebKitGTK+ and many more.

It supports Linux and possibly Windows.  Guile GI, including this
documentation, is licensed under the LGPLv2.1+

If you want to write a Guile application for GNOME or a Guile GUI
application using GTk+, then Guile GI (when it is finished) will be
the way to go.  For more information on specific libraries, check out
the ``Guile Gtk+ 3 Tutorial'' and ``Guile GIO Tutorial''
chapters. (FIXME: write these.)

(Guile GI is derived from PyGObject.  This document is derived from
their documents.)

@node Getting Started, Tutorials, Preface, Top
@chapter Getting Started

To get things started, we will try to run a very simple GTK+ based GUI
application using the bindings provided by Guile GI.  First, create a
small Guile script called @file{hello.scm} with the following content
and save it somewhere (FIXME, this doesn't work):

@lisp
(use-modules (gi))
(require-version "Gtk" "3.0")
(import "Gtk")

(define window (Window #:title "Hello World"))
(show window)
(connect window main-quit)
(main)
@end lisp

Before we can run the example application, we need to install Guile
GI, GTK+, and their dependencies.

When it is run, it will create an empty window with a title.  Are you
impressed?

@menu
* Installation::
* Sample Applications::
@end menu

@node Installation, Sample Applications, Getting Started, Getting Started
@section Installation

@node Sample Applications,  , Installation, Getting Started
@section Sample Applications

@menu
* Example 1::
@end menu

@node Example 1,  , Sample Applications, Sample Applications
@subsection Example 1

@node Tutorials, Reference Guide, Getting Started, Top
@chapter Tutorials

@menu
* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::
@end menu

@node Threads and Concurrency, Debugging and Profiling, Tutorials, Tutorials
@section Threads and Concurrency

@node Debugging and Profiling, Application Deployment, Threads and Concurrency, Tutorials
@section Debugging and Profiling

@node Application Deployment, Testing and Continuous Integration, Debugging and Profiling, Tutorials
@section Application Deployment

@node Testing and Continuous Integration,  , Application Deployment, Tutorials
@section Testing and Continuous Integration

@node Reference Guide, Further Resources and Contact Info, Tutorials, Top
@chapter Reference Guide

The Guile GI project provides two Guile modules, @file{(gi)}, and
@file{(gobject)}.  The @file{(gi)} module is an interface for
dynamically creating Guile modules for GObject-based libraries by
examining the information in their @file{.typelib} files. The
@file{(gobject)} module is an interface for creating new GObject
classes and instances in Guile.  These two modules allow one to write
programs using GObject-based C libraries like GTK3 or WebKitGTK.

@c -----------------------------------------------------------------
@menu
* gi module::
* gobject module::
@end menu

@node gi module, gobject module, Reference Guide, Reference Guide
@section The @file{(gi)} module

The @code{(gi)} module contains procedures that dynamically create
Guile interfaces for GObject-based libraries.  The interfaces are
created by examining the information in their @emph{typelib} files.  A
typelib file contains information on the public classes, functions,
and variables in a GObject-based library.  Rather than using
filenames, @emph{namespace} strings are used to refer to typelib
files.  Some well known namespace strings are ``Gtk'' and ``Glib''.

A minimal example for this library would be to parse a typelib file
using the @code{require-version} procedure, and then generate the
bindings using the, @code{import} procedure, as in the following
example. The autogenerated interface will be loaded into the current
module.

@lisp
(use-modules (gi))
(require-version "Gtk" "3.0")
(import "Gtk")
@end lisp

@deffn Procedure require-version namespace version
Given @var{namespace}, a string like ``Gtk'', and @var{version}, a
string containing a version like ``3.0'', @code{require-version}
ensures the typelib file for this namespace get loaded with the given
version.  If the namespace was already loaded with a different version
or if a different version was required previously, it will raise an
error.

The return value is unspecified.
@end deffn

@deffn Procedure import namespace
Given @var{namespace}, a string like ``Gtk'', this procedure
autogenerates bindings to the library and loads them into the current
module.  Note that the namespace must already be loaded by using the
@code{require-version} procedure, or an error will be thrown.

The return value is unspecified.
@end deffn

@deffn Procedure require-foreign namespace
Given @var{namespace}, a string of the form ``cairo'',
@code{require-foreign} ensures that the interface for a given library
gets loaded.  Unlike the @code{require-version} procedure, which loads
interfaces from GObject typelib files, this procedure loads interfaces
@emph{coded into Guile GI itself}.  These interfaces are created when
Guile GI is compiled, and cannot be modified later without recompiling
Guile GI.

In practice, only one such interface exists.  It is the interface for
the Cairo drawing library.

It will throw an error if the given interface does not exist.  The
return value is unspecified.
@end deffn

@deffn Procedure check-version namespace version
Given @var{namespace}, a string like ``Gtk'', and @var{version}, a
string containing a version like ``3.0'', @code{check-version} 
will throw an error if the given namespace was not already loaded
using @code{require-version}.  Otherwise, it does nothing.

The return value is unspecified.
@end deffn

@deffn Procedure get-required-version namespace
Given @var{namespace}, a string like ``Gtk'', this procedure returns,
as a string, the version of any namespace previously loaded by
@code{require-version}.  If the given namespace was not previously
loaded, it returns @code{#f}.
@end deffn

@defvr Variable version-info
This variable is set to a list of 3 integers that represent the
version of Guile GI.
@end defvr


@node gobject module,  , gi module, Reference Guide
@section The @file{(gobject)} module 

The @code{(gobject)} module lets you interact with the C type system
used by the Glib and GObject libraries.  In Glib and GObject, they
define a kind of class structure in C.  Those classes have three
notable features.

@itemize
@item
Each GObject class has an integer identifier called a @code{GType}.

@item
Each GObject class has zero or more @emph{properties}, which are class
slot variables.  Unlike in GOOPS, the slot variables have a specified
type: integer, string, etc.

@item
And a GObject class may also have @emph{signals}.  Signals are a
GObject system for registering callbacks for specific events.
@end itemize

The @code{(gobject)} module contains functionality to define GOOPS
classes that can interact with the GObject type system. When using
this module, a new class is defined with the
@code{make-gobject-type} procedure.

@defvr Variable Object
This @code{Object} variable holds the GObject base class type. You can
derive new GObjects from this type.  It may be used as the superclass
in @code{make-gobject-type}.
@end defvr

@deffn Procedure make-gobject-type name superclass ...
Makes a new Guile foreign object type for use with GObject. @var{name}
is a symbol naming the type. The @code{superclass} is a GObject type
that this class inherits from.  Every class must descend from another
class.  (See Object).

After the name and the superclass, you may add property specifiers and
signal specifiers.  Each property specifier adds a variable to the
class.  Each signal specifier adds a signal that the class may emit.

Unlike in GOOPS classes, in GObject classes, the property variables
variables need to have a predefined type.  These properties are in
addition to any properties defined by the superclass.

For each property you need to provide the following information as a
list.  The details of defining a properties specifier is detailed
below, but as an example:

@lisp
('property "height" G_TYPE_DOUBLE "Height" "How tall"
    0.0 300.0 175.0 G_PARAM_READWRITE)
('property "weight" G_TYPE_DOUBLE "Weight" "How fat"
    0.0 300.0 75.0 G_PARAM_READWRITE))
@end lisp

The numerical values in the example above are the minimum, maximum,
and default values.

For each signal that the instances of the class may emit, you need to
add a signal specifier.  The details of signal specifiers are below,
but, as an example
@lisp
('signal "mouse-click" G_SIGNAL_RUN_FIRST
  G_TYPE_INT                           ; return type
  (list G_TYPE_DOUBLE G_TYPE_BOOLEAN)) ; parameter types
@end lisp

The procedure returns the new type.
@end deffn

An instance (or object) of a GObject type can be created with the
@code{make} procedure which is part of GOOPS. @code{make} takes one
parameter, which is the class of the instance to create.  For
instance, the following form

@lisp
(define c (make <my-gobject-type>))
@end lisp

To get and set the properties of an instance of a gobject type, use
the @code{property-set!} and @code{property-get} procedures.

To connect a class method to be used as a callback when a signal is
emitted, use the @code{callback} procedure.

To find a list of all the signals for a given class, use
@code{signal-list-names}.

To emit a signal, use the @code{emit} method.

@node Further Resources and Contact Info, Index, Reference Guide, Top
@chapter Further Resources and Contact Info

@node Index,  , Further Resources and Contact Info, Top
@unnumbered Index

@printindex cp

@bye
