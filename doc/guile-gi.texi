\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename guile-gi.info
@settitle Guile GI
@c %**end of header

@copying
Copyright @copyright{} 2018 Michael L. Gran

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
@end copying

@titlepage
@title Guile GI
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@c @ifnottex
@node Top, Preface, (dir), (dir)
@top Guile GI

This manual is for Guile GI.
@c @end ifnottex

@menu
* Preface::
* Getting Started::
* Tutorials::
* Reference Guide::
* Further Resources and Contact Info::
* Gnu Free Documentation License::
* _index::

@detailmenu
 --- The Detailed Node Listing ---

Getting Started

* Installation::
* Sample Applications::

Sample Applications

* Example 1::

Tutorials

* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::

Reference Guide

* typelib introspection procedures::
* GObject types::

@end detailmenu
@end menu

@node Preface, Getting Started, Top, Top
@unnumbered Preface
Guile GI is a Guile package that hopes to provide access for
GObject-based libraries such as GTK+, GLib, WebKitGTK+ and many more.

It supports GNU/Linux, and has only been tested with Guile-2.2. Guile
GI, including this documentation, is licensed under the LGPLv2.1+

If you want to write a Guile application for GNOME or a Guile GUI
application using GTk+, then Guile GI (when it is finished) will be
the way to go.

@node Getting Started, Tutorials, Preface, Top
@chapter Getting Started

To get things started, we will try to run a very simple GTK+ based GUI
application using the bindings provided by Guile GI.

First, create a @code{(Gtk)} Guile module and a @code{(Gio)} Guile
module.

@example
guile -L . -c '(use-modules (gi)) (display (export-typelib "Gtk" "3.0"))' > Gtk.scm
guile -L . -c '(use-modules (gi)) (display (export-typelib "Gio" "2.0"))' > Gio.scm
@end example

The, a minimal GTK application looks like this

@lisp
(use-modules (gi)
	     (Gtk)
	     ((Gio) #:prefix Gio)
	     )

(load-typelib "Gtk" "3.0")
(load-typelib "Gio" "2.0")

(define (activate app user-data)
  (let ((window (ApplicationWindow-new app)))
    (Window-set-title window "Window")
    (Window-set-default-size window 200 200)
    (Widget-show-all window)))

(define (main)
  (let ((app (Application-new "org.gtk.example" 0)))
    (signal-connect app "activate" activate #f)
    (GioApplication-run app (length (command-line)) (command-line))))

(main)
@end lisp

When it is run, it will create an empty window with a title.  Are you
impressed?

@menu
* Installation::
* Sample Applications::
@end menu

@node Installation, Sample Applications, Getting Started, Getting Started
@section Installation

The library has no proper build system yet.  It just has a simple
@file{Makefile}.  If you are lucky, just typeing ``make'' may build
it.

@node Sample Applications,  , Installation, Getting Started
@section Sample Applications

@menu
* Example 1::
@end menu

@node Example 1,  , Sample Applications, Sample Applications
@subsection Example 1

@node Tutorials, Reference Guide, Getting Started, Top
@chapter Tutorials

@menu
* Threads and Concurrency::
* Debugging and Profiling::
* Application Deployment::
* Testing and Continuous Integration::
@end menu

@node Threads and Concurrency, Debugging and Profiling, Tutorials, Tutorials
@section Threads and Concurrency

@node Debugging and Profiling, Application Deployment, Threads and Concurrency, Tutorials
@section Debugging and Profiling

@node Application Deployment, Testing and Continuous Integration, Debugging and Profiling, Tutorials
@section Application Deployment

@node Testing and Continuous Integration,  , Application Deployment, Tutorials
@section Testing and Continuous Integration

@node Reference Guide, Further Resources and Contact Info, Tutorials, Top
@chapter Reference Guide

The Guile GI project provides a Guile module @file{(gi)}.  The
@file{(gi)} module is an interface for dynamically creating Guile
modules for GObject-based libraries by examining the information in
their @file{.typelib} files.

@c -----------------------------------------------------------------
@menu
* typelib introspection procedures::
* GObject types::
@end menu

@c -----------------------------------------------------------------
@node typelib introspection procedures, GObject types, Reference Guide, Reference Guide
@section Typelib introspection procedures

A GObject typelib file contains information on the public classes,
functions, and variables in a GObject-based library, and most
GObject-complient libraries, such as GLib and GTK, provide one.
Usually these files are on the filesystem in a single directory
location.  On Fedora, for example, these files may be stored in
@file{/var/lib64/girepository-1.0}.

@deffn Procedure get-typelib-search-path
This returns, as a list of strings, the current search path used to find
typelib files.

If it returns an empty list, this indicates that it is only searching
the default typelib directory.
@end deffn

@deffn Procedure prepend-typelib-search-path directory
Given @var{directory}, a string representation of a filesystem
directory, this prepends that directory to the typelib search path.
@end deffn

@deffn Procedure export-typelib namespace version
Given @var{namespace}, a string that names a typelib library, such as
``Gtk'' or ``GLib'', and @var{version}, a string that names a version
of a typelib library, like ``2.0'' or ``3.0'', this procedure parses a
typelib file and generates the Scheme source code for a binding to the
library.  The source code is returned as a string, which you should
save to a file.

The procedure may throw an error if a typelib file corresponding to
@var{namespace} and @var{version} cannot be found.
@end deffn

@deffn Procedure import-typelib namespace version
Given @var{namespace}, a string that names a typelib library, such as
``Gtk'' or ``GLib'', and @var{version}, a string that names a version
of a typelib library, like ``2.0'' or ``3.0'', this procedure parses a
typelib file and generates procedures, constants, and types which are
loaded into the current environment.

The procedure may throw an error if a typelib file corresponding to
@var{namespace} and @var{version} cannot be found.

This procedure implicitly calls @code{load-typelib}.

The return value is unspecified.
@end deffn

@deffn Procedure load-typelib namespace version
Given @var{namespace}, a string that names a typelib library, such as
``Gtk'' or ``GLib'', and @var{version} a string that names a version
of a typelib library , like ``2.0'' or ``3.0'', this procedure reads a
typelib file, and indexes the information in the typelib file into
several hash tables.  The hash tables are created in the current
environment, and have names such as @code{%gi-constants} and
@code{%gi-functions}.

The procedure may throw an error if a typelib file corresponding to
@var{namespace} and @var{version} cannot be found.

The return value is unspecified.
@end deffn

@defvar %gi-constants
@defvarx %gi-enums
@defvarx %gi-flags
@defvarx %gi-functions
@defvarx %gi-methods
@defvarx %gi-callbacks
@defvarx %gi-structs
@defvarx %gi-unions
@defvarx %gi-objects
@defvarx %gi-interfaces
@defvarx %gi-signals
These are all hash tables generated by @code{load-typelib}.  They
contain information parsed from a typelib file and indexed for easier
access by procedures such as @code{gi-constant-value} and
@code{gi-function-invoke}.
@end defvar

@deffn Procedure gi-constant-value name
@deffnx Procedure gi-flag-value category name
@deffnx Procedure gi-enum-value category name
@deffnx Procedure gi-struct-ref ptr type-name field-name
@deffnx Procedure gi-struct-set ptr type-name field-name value
@deffnx Procedure gi-function-invoke name [args...]
@deffnx Procedure gi-method-prepare name [args...]
@deffnx Procedure gi-method-send object list-of-args
@deffnx Procedure gi-lookup-type name
@deffnx Procedure gi-lookup-callback-info name
These procedures are used to generate the bindings.  They lookup
introspection information stored in hash tables generated by the
@code{load-typelib} procedure and convert between C and Guile types.

They are used in the procedures generated by @code{export-typelib} and
@code{import-typelib}.
@end deffn

@c -----------------------------------------------------------------
@node GObject types,  , typelib introspection procedures, Reference Guide
@section GObject Types

If you inspect the bindings generated by @code{load-repository}, you
will notice many references to the helper functions
@code{gi-function-invoke}, @code{gi-method-prepare}, and
@code{gi-method-send}.  These procedures convert Guile parameters and
return values to GObject-friendly C parameters and return values.

If you look at the bindings generated by @code{export-typelib}, the
comments and docstrings indicate the types expected by the procedures.

For integer and string arguments, the C to Guile conversions are the
obvious ones. But for GObject types, things get a bit more complex.
GObject has three classes of custom types: structs, unions, and
objects.

GObject unions and structs are handled in Guile-GI by storing them in
a @code{<GBox>} foreign object type.  @code{<GBox>} types are
typically opaque.  The can be created and by GObject functions and
used as arguments, but, their contents aren't otherwise modifyiable.

GObject objects are stored in a @code{<GObject>} foreign object type.
They have slightly more interactivity available at the Guile layer.
They have properties that can be queried and Guile procedures can be
hooked into the GObject callback layer, which GObject calls ``signals''.

@deffn Procedure gobject-type-name obj
Given @var{obj}, a GObject, this returns that name of its type as a
string.
@end deffn

@deffn Procedure gobject-get-property obj prop
@deffnx Procedur gobject-set-property! obj prop val
Given @var{obj}, a GObject and  @var{val}, a string name of an object property,
these procedures get and set properties of the GObject.
@end deffn

@deffn Procedure signal-connect obj signal-name procedure rest
Given @var{obj}, a GObject instance, @var{signal-name}, @var{procedure},
a procedure to be used as a callback, and @var{rest}, this attaches
the callback procedure to the object so that it is called when the
GObject signal is emitted.
@end deffn

@subsection On Guile to C Type Conversions

Guile-GI uses a rule system to convert Guile procedure arguments to C
types.  Typically these conversions between Guile and C types are
straightforward, but, some conversions are tricky and need additional
description.

@subsubsection Strings

GObject libraries usually use UTF-8 encoding for their strings, while
Guile uses a different encoding internally for its strings.  Thus
every time a string is parameter is passed through to a C procedure, a
new UTF-8 copy of the Guile string is created.  The string is
automatically freed when no longer in use.

GObject has some procedures that deal with locale-encoded strings:
notably those procedures that deal with environment variables.
Guile-GI converts Guile strings to locale-encoded strings for those
procedures.  Note that this may throw an encoding error if the Guile
string cannot be represented in the current locale.

@subsection C Arrays

There are many different types of C arrays, and the Guile types
expected for GObject procedures that C arrays varies depending on the
type required.

Typically, for simple C arrays of numerical types -- integers, floating
points, etc -- a Guile bytevector needs to be used.  For these
bytevectors, always use native-endianness.

For C arrays of GObject objects, structs, unions, flags, enums, and
GTypes, a @emph{list} is used instead of a bytevector.

If the C procedure expects a zero-terminated array, Guile-GI will
provide that automatically.  There is no need to add you own zero.

Some GObject procedures write output information into preallocated C
arrays.  For those procedures, the Guile caller will need to create
and pass in a bytevector of the appropriate size.

@quotation Warning
It is best not to use any of GLib's @code{Array} and @code{ByteArray}
procedures directly.  Since arrays get converted to bytevectors, these
procedures will likely fail to do anything sensible.
@end quotation

@node Further Resources and Contact Info, Gnu Free Documentation License, Reference Guide, Top
@chapter Further Resources and Contact Info

Uh, I dunno.

Maybe the Guile mailing list?

@node Gnu Free Documentation License, _index, Further Resources and Contact Info, Top
@chapter Gnu Free Documenation License
@include fdl-1.3.texi

@node _index,  , Gnu Free Documentation License, Top
@unnumbered Index

@printindex cp

@bye
