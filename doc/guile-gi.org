#+title: Guile GI
#+author: Michael L. Gran

#+startup: indent
#+language: en

#+macro: command @@texinfo:@command{$1}@@
#+macro: env @@texinfo:@env{$1}@@
#+macro: file @@texinfo:@file{$1}@@
#+macro: var @@texinfo:@var{$1}@@
#+macro: xref @@texinfo:@xref{$1,$2,$3,$4,$5}@@

* Copying
:PROPERTIES:
:COPYING: t
:END:

Copyright @@texinfo:@copyright{}@@ 2018, 2019 Michael L. Gran

#+begin_quote
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled ``GNU
Free Documentation License''.
#+end_quote

* Preface
:PROPERTIES:
:UNNUMBERED: t
:END:
Guile GI is a Guile package that hopes to provide access for
GObject-based libraries such as GTK+, GLib, WebKitGTK+ and many more.

It supports GNU/Linux, and has only been tested with Guile-2.2. Guile
GI is licensed under the LGPLv2.1+. This documentation is licensed under
the FDLv1.3+.

If you want to write a Guile application for GNOME or a Guile GUI
application using GTK+, then Guile GI (when it is finished) will be
the way to go.

* Getting Started
#+attr_texinfo: :options Warning
#+begin_quotation
Guile-GI is still in its experimental phase and even so, this documentation
describes features of vastly different age. Don't be too surprised if something breaks.
#+end_quotation

To get things started, we will try to run a very simple GTK+ based GUI
application using the bindings provided by Guile GI.

Now, to understand how this works, one needs to distinguish between
what Guile-GI provides and the bindings that it creates.

- Guile-GI itself is a library that allows you to parse ~typelib~
  files, which describe code modules.  It has a handful of procedures
  for inspecting ~typelib~ files as well as some helper procedures
  for dynamically creating procedures and types.
- When Guile-GI is used, it creates procedures, variables, and types
  according to the instructions in the ~typelib~ files.  These are
  created /at runtime/ when the Guile-GI procedure
  ~typelib-load~ is called.

First, for each GObject library that you want to use in your program,
you need to have an export library.  A sample library for GTK+3 could
take the following form.

#+begin_example
(define-module (gi gtk-3)
  #:use-module (gi))

(typelib-load "Gtk" "3.0")
#+end_example

Alternatively, you can instruct Guile-GI to create these modules for you, as
shown in the following.

#+begin_example
(use-modules (gi))
(use-typelibs ("GLib" "2.0") ("Gtk" "3.0"))
#+end_example

Here, Guile-GI creates the (hopefully unique) modules ~(%gi GLib-2.0)~ and ~(%gi Gtk-3.0)~
and imports them into the current module using ~use-modules~.

For these auto-generated libraries, you are going to need some
documentation. The procedure ~typelib-document~ creates some
rough documentation for a ~typelib~: it gives the procedure names
and how they are called, plus a list of types and constants.  For
example, the following commands would make some rough documentation
for GTK and GIO.

#+begin_example
guile -L . -c '(use-modules (gi)) (display (typelib-document "Gtk" "3.0"))' > Gtk.txt
guile -L . -c '(use-modules (gi)) (display (typelib-document "Gio" "2.0"))' > Gio.txt
#+end_example

{{{xref(Typelib Introspection)}}} for more information on ~typelib-load~ and ~typelib-document~.

A minimal GTK application looks like this
#+begin_export texinfo
@example
@include example-1.scm
@end example
#+end_export

When it is run, it will create an empty window with a title.  Are you impressed?

Let's walk through this example.  First off, you may notice two important procedures:
~make~ and ~connect~, as well as a few types, most notably ~<GtkApplication>~ and ~signal~.
These procedures and types allow you to interact with GObject's very odd class system.

First is ~make~, which wraps and extends the ~make~ procedure found in GOOPS.
{{{xref(GOOPS,,,guile,The Guile reference manual)}}} for infos about GOOPS.
In short the arguments, that would normally be used for slot initialization are instead used
to initialize properties.
This is an important distinction, as objects are represented in Scheme as GOOPS objects, whose
slots *do not* map to properties.
It also takes care of some types, which do not derive from GObject, such as boxed types.

Next is ~connect~, which connects Guile procedures as handlers to GObject signals.
Signals are roughly equal to hooks.
Note, that ~(gi)~ only defines ~connect~ in terms of signal objects, while signals
are not yet exported as objects from typelibs. Hence we define our own connect method, which translates
symbols to signal objects. In future, this will no longer be necessary and
~(connect object signal handler)~ should work without quoting the signal.

{{{xref(GObject Methods)}}} for more information on how to use methods.
{{{xref(GObject Signals)}}} for more information on how to use signals.
{{{xref(GObject Properties)}}} for more information on how to use properties.
** Installation
In some happy future, you might be able to get this from whatever method
your operating system normally uses to download free software.

If you are trying to build this from the Git repository, use
{{{command(git clone)}}} to copy the tree onto your computer. After closing
the repository, you need to run {{{command(autoreconf)}}} to generate a
{{{file(configure)}}} file.

If you are building from a {{{file(guile-gi.zip)}}} file or a
{{{file(guile-gi.tar.gz)}}}, unpack the file.

From there, running {{{command(configure)}}}, then {{{command(make)}}}, then
{{{command(sudo make install)}}} will give you a running system.

In the file archives, look for files named {{{file(INSTALL)}}} for detailed
instructions.

** Sample Applications
*** Example 1
* Tutorials
** GObject Types and Guile Types
Every time you call a GObject procedure provided by Guile-GI, the
Guile arguments need to be converted to C arguments, and the return
values need to be converted back into Guile values. For integer and
string arguments, the C to Guile conversions are straightforward; for
GObject types -- such as GTK's ~GtkWindow~ or ~GtkButton~ or
GLib's ~GDate~ -- a Guile object needs to be converted into a C
structure.  Hopefully, in normal circumstances, this conversion will
happen automatically without difficulty.

GObject types have different categories.  Some are simple C structs
and unions.  Others are /objects/, which is GObject's class
hierarchy upon which the windowing library GTK is built.

Explaining how Guile-to-C type conversion is accomplished under the
hood can be slightly confusing because there are several different
things named `type':

1. the C typedef of a structure, union or object, such as ~struct GtkWindow~
2. the C ~GType~, a unique integer ID that GObject libraries provide
   for each C typedef'd structure, union, or object
3. the Guile class ~<GType>~ created by Guile-GI for each GType to hold instances
   of the associated C structure

For example, GLib has a type ~GDate *~ which holds information
about a calendar date.  The ~GDate *~ typedef has an associated
~GType~ integer ID.  The Guile class ~<Date>~ is created to
hold structures with that ~GType~.  When using GLib's date
functions from Guile, instances of ~GDate *~ are held by
instances of the Guile class ~<Date>~.

Internally to Guile-GI, all of the Guile classes for GObject structs,
objects and unions are GOOPS types that handle managing the C pointer.
The C pointer is ``hidden'' in the ~ptr~ slot of an object.
** Threads and Concurrency
While Guile is multi-threaded, applications using Guile-GI are not
fully thread-safe.  Notably, applications using GTK or GLib's mainloop
need all rendering and mainloop activities to occur in one thread.
Also, all calls to ~typelib-load~ need to be made from the same
thread.
** Debugging and Profiling
Guile-GI makes use of GLib's debug logging.  Running a program with
the {{{env(G_MESSAGES_DEBUG)}}} environment variable set to ~all~ will
provide a full trace of the function calls in Guile-GI.  For more
information on how to take advantage of this logging, see
[[https://developer.gnome.org/glib/stable/glib-running.html]].
** Application Deployment
If you write a program in Guile-GI and wish to share it
with the world, you will need to ensure your users have
all the prerequisites.

At a minimum, Guile-GI scripts will require that users have the
following packages.

- Guile
- Guile-GI
- libffi
- GLib
- GObject Introspection aka GIRepository

And then, of course, a Guile-GI program will additionally
require whatever libraries its uses (GTK, WebKit2) as well
as their associated typelib files.
** Testing and Continuous Integration
The distribution does contain a couple of scripts that should enable it
to be built by Travis-CI.  In the root directory, there is a
~.travis.yml~ and a ~Dockerfile~ that work together.  The
docker container pulls the latest version of Ubuntu, and the YML file
builds the project and runs ~make distcheck~.

* Reference Guide
The Guile GI project provides a Guile module {{{file((gi))}}}.  The
{{{file((gi))}}} module is an interface for dynamically creating Guile
modules for GObject-based libraries by examining the information in
their {{{file(.typelib)}}} files.

** Typelib Introspection
A GObject typelib file contains information on the public classes,
functions, and variables in a GObject-based library, and most
GObject-complient libraries, such as GLib and GTK, provide one.
Usually these files are on the filesystem in a single directory
location.  On Fedora, for example, these files may be stored in
{{{file(/var/lib64/girepository-1.0)}}}.

#+attr_texinfo: :options Procedure typelib-get-search-path
#+begin_deffn
This returns, as a list of strings, the current search path used to find
typelib files.

If it returns an empty list, this indicates that it is only searching
the default typelib directory.
#+end_deffn

#+attr_texinfo: :options Procedure typelib-prepend-search-path directory
#+begin_deffn
Given {{{var(directory)}}}, a string representation of a filesystem
directory, this prepends that directory to the typelib search path.

If using this procedure in a script, it must be called before any
calls to ~typelib-load~.
#+end_deffn

#+attr_texinfo: :options Procedure typelib-document namespace version
#+begin_deffn
Given {{{var(namespace)}}}, a string that names a typelib library, such as
``Gtk'' or ``GLib'', and {{{var(version)}}}, a string that names a version
of a typelib library, like ``2.0'' or ``3.0'', this procedure parses a
typelib file and generates documentation of the Scheme procedures, types,
and constants that will be provided by calling ~typelib-load~.
The documentation is returned a a string.

The procedure may throw an error if a typelib file corresponding to
{{{var(namespace)}}} and {{{var(version)}}} cannot be found.
#+end_deffn

#+attr_texinfo: :options Procedure typelib-load namespace version
#+begin_deffn
Given {{{var(namespace)}}}, a string that names a typelib library, such as
``Gtk'' or ``GLib'', and {{{var(version)}}}, a string that names a version
of a typelib library, like ``2.0'' or ``3.0'', this procedure parses a
typelib file and generates procedures, constants, and types which are
loaded into the current environment.

The procedure may throw an error if a typelib file corresponding to
{{{var(namespace)}}} and {{{var(version)}}} cannot be found.
#+end_deffn
** GObject Types
For integer and string arguments, the C to Guile conversions are the
obvious ones. But for the specialized GObject types, things get a bit
more complex.  GObject has three classes of custom types: structs,
unions, and objects.

GObject /unions/ and /structs/ are handled in Guile-GI by
creating a GOOPS type that wraps a C pointer.  Typically,
instances can be created and by GObject functions and used as
arguments, but, their contents aren't otherwise modifyiable.  GObject
unions and structs may have GObject Methods, but do not have signals
or properties.

GObject /objects/ are also stored by creating a GOOPS
type that wraps a C pointer.  Unlike GObject structs and unions, they
have more interactivity available at the Guile layer.  They have
properties that can be queried and Guile procedures can be hooked into
the GObject callback layer, which GObject calls ``signals''.

For each custom GObject type, Guile-GI creates a variable that holds
the GOOPS type.  That variable has the form ~<TYPE>~,
where TYPE is the GObject type name. To check whether an object
has a given type, use the ~is-a?~ procedure found in GOOPS, which
Guile-GI re-exports.

#+begin_example
(use-modules (gi))
(use-typelibs ("GObject" "2.0") ("Gio" "2.0"))
(is-a? (make <GApplication>) <GObject>)
;; => #t
#+end_example

Each GObject struct, union, or object has a place in the GObject
single-inheritance class structure.  A ~RadioButton~ is a type of
~Button~ is a type of ~Widget~, for example.  If you wish to
introspect a GObject's type, use ~get-gtype~ and then use the GType
procedures.

{{{xref(GType)}}} for more information on type introspection.

** GType
A ~<GType>~ is a Guile type, which corresponds to a ~GType~.
A ~GType~ is basically an integer ID (an ~<integer>~ in Scheme),
that GObject uses to identify a type.

GObject has its own custom class structure.  The following procedures
provide information about how a ~<GType>~ forms part of that
class structure.

#+attr_texinfo: :options Procedure get-gtype object
#+begin_deffn
Given {{{var(object)}}}, a GObject struct, union, or object, this procedure
returns its GObject type as an ~<integer>~, otherwise it returns ~#f~.
#+end_deffn

#+attr_texinfo: :options Procedure gtype-get-scheme-type gtype
#+begin_deffn
Given {{{var(gtype)}}} of type ~<integer>~, this procedure will return
the Scheme type that holds instances of that type.
#+end_deffn

#+attr_texinfo: :options Procedure gtype-get-name gtype
#+begin_deffn
Given {{{var(gtype)}}} of type ~<integer>~, this procedure returns
a string with GObject's internal name for this type.  This may differ
slightly from the name that Guile-GI gives to the type.
#+end_deffn


#+begin_export texinfo
@deffn Procedure gtype-get-parent gtype
@deffnx Procedure gtype-get-children gtype
These procedures return the parent type and the child types of a
specified @var{gtype}.
@end deffn
#+end_export

#+attr_texinfo: :options Procedure gtype-is-a? object type
#+begin_deffn
Returns ~#t~ of {{{var(object)}}} is an instance of a {{{var(type)}}}.
#+end_deffn
** GObject Methods
Guile-GI exports object methods as GOOPS methods in the formats
~type:method~ and ~method~, where {{{var(type)}}} is the
type of an object sans namespace translated into ~kebab-case~ and
{{{var(method)}}} is the name of the method translated into
~kebab-case~. For instance ~gtk_widget_show~
is bound to both ~widget:show~ and ~show~.

Use whichever bindings you prefer or alternatively rename them using the
~#:rename~ argument to ~use-modules~ or
~use-typelibs~ respectively. Note that Guile currently warns if a binding
is imported from multiple libraries (e.g. both GLib and Gtk), but this should
not concern you in most cases, as both internally specialize the same generic method.

** GObject Signals
GObjects have a functionality for defining and calling callback
procedures that it calls /signals/.  Note that these signals
have nothing to do with Unix signals like ~SIGTERM~.

To hook a callback procedure to an object's signal, use the
~connect~ procedure. Consider the following example.

#+begin_example
(define (activate app)
   ...
   )

(define activate-signal (make <signal> #:name "activate"))

(connect app              ; A GObject
         activate-signal  ; A <signal> object
         activate)        ; A procedure to call when emitted
#+end_example

In that example, the caller is attaching a procedure named
~activate~ to the object ~app~'s ``activate'' signal.  When
the gobject object calls all the callback procedures attached to its
``activate'' signal it will call this ~activate~ procedure.

When a callback procedure is called it may receives some arguments
from the caller and some from user data.  In the example, ~activate~
is supposed to take a single argument.
This argument -- ~app~ -- is supplied by the caller, as are all
arguments to signals.

#+begin_export texinfo
@deffn Procedure connect obj (signal <signal>) (handler <procedure>)
@deffnx Procedure connect obj (signal <signal>) (detail <symbol>) (handler <procedure>)
@deffnx Procedure connect-after obj (signal <signal>) (handler <procedure>)
@deffnx Procedure connect-after obj (signal <signal>) (detail <symbol>) (handler <procedure>)
Hooks @var{handler} to emissions of @var{signal}.
If @var{detail} is supplied, only emissions in which the detail matches it are considered.

@code{connect-after} works like @code{connect}, except that the handler is run @emph{after}
the main handling code.
@end deffn
#+end_export

Signal objects can also be used to emit signals. Note that you shouldn't normally do this when
using objects of types, that you didn't define, and even when using objects of types,
that you did define, you should only emit the signals that you defined for that object
(and perhaps the ``notify'' signal when using explicit notification).

#+attr_texinfo: :options signal obj [detail] [args...]
#+begin_defspec
Emits the {{{var(signal)}}} signal of {{{var(obj)}}} with {{{var(detail)}}} and {{{var(args)}}}.
Note, that the interpretation of {{{var(detail)}}} depends on whether or not {{{var(signal)}}} is detailed.
If it is, {{{var(detail)}}} needs to be a symbol, that will be translated to the detail of the emission.
If it is not, it is considered the first argument and will be consed with {{{var(args)}}} to form
an argument list.
#+end_defspec

Signals have several slots, that can be bound on creation time
(and reassigned freely, since they are proper GOOPS objects).
When connecting signals, only {{{var(name)}}} needs to be supplied.
When using them as proper signals, at least {{{var(return-type)}}} needs to be given as well.

#+attr_texinfo: :options Slot name
#+begin_defvr
The name of the signal.
A string.
#+end_defvr

#+attr_texinfo: :options Slot return-type
#+begin_defvr
The return type of the signal.
A ~<GType>~ or integer.
#+end_defvr

#+attr_texinfo: :options Slot param-types
#+begin_defvr
The parameter types of the signal.
A list of ~<GType>~ classes or integers.
#+end_defvr

#+attr_texinfo: :options Slot accumulator
#+begin_defvr
A procedure, called with two arguments {{{var(seed)}}} and {{{var(current)}}} and
produces up to two output values.
If it produces no output value, {{{var(seed)}}} is left unchanged and signal handling
continues.
If it produces one output value, {{{var(seed)}}} is set to that value and signal handling continues.
If it produces two output values, {{{var(seed)}}} is set to the second output value and signal
handling stops if the first is ~#f~.
If at any time {{{var(seed)}}} would be set to an incorrect value or more than two values are returned
signal handling is aborted.
#+end_defvr

#+attr_texinfo: :options Slot flags
#+begin_defvr
Signal flags, a logical or of  one or more of
~SIGNAL_RUN_FIRST~, ~SIGNAL_RUN_LAST~,
~SIGNAL_RUN_CLEANUP~, ~SIGNAL_NO_RECURSE~, etc.
#+end_defvr

** GObject Properties
GObject objects may have one or more properties, which are variables
attached to the object that may be gotten or set.  GObject properties
usually have C-like types.  Remember that GObject objects are
instances of a class that may have a parent class, and each parent
class may one or more properties. So, for example, if the object is a
radio button, you may get or set properties that apply specifically to
radio buttons, or generic buttons, or generic widgets.

The ~get-property~ and ~set-property!~ procedures are provided
to set GObject properties.

#+begin_export texinfo
@deffn Procedure get-property obj prop
@deffnx Procedure set-property! obj prop val
Gets or sets and object's property. @var{prop} is the symbol name
of the property to set.

It will throw an error if the property does not exist, or if the
setting value has the wrong type.
@end deffn
#+end_export

Alternatively, you can also use parameter types,
(i.e. ``objects'', that derive from ~G_TYPE_PARAM~ alias ~<GParam>~)
as accessors. Assuming, that e.g. ~prop~ is bound to such an object,
~(prop obj)~ will fetch the corresponding property, whereas
~(set! (prop obj) val)~ will set it.

** Defining new GObject classes
:PROPERTIES:
:ALT_TITLE: Custom GObjects
:DESCRIPTION: Defining new GObject classes
:END:
Usually any GObjects you use will be created by procedures such as
~window:new~, and those GObject types will have been predefined
in the typelib. But, it is possible to make custom GObject object
classes using the ~register-type~ procedure.

Bear in mind, that while Guile-GI internally uses GOOPS, GObjects implemented in it
are not quite as flexible. For instance, you can not meaningfully redefine a
GObject-based type, which you could if you just used GOOPS types.
On the other hand, you can make use of the features of the GObject infrastructure,
such as signals.

Defining a new GObject class is rather complicated.

#+attr_texinfo: :options Procedure register-type type-name parent-type list-of-properties list-of-signals disposer
#+begin_deffn
This procedure creates and returns a new ~<GType>~ of a GObject
object.

{{{var(type-name)}}} is the string name of the new type. Note, that it will be
turned into a symbol internally.

{{{var(parent-type)}}} is the ~<GType>~ of the parent class to this
class.  The parent class needs to be ~<GObject>~ or a GObject
class that descends from it.

{{{var(list-of-properties)}}} is a list of parameter specifications.
These parameter specifications can be created using the ~param-spec-TYPE~
methods found in the ~GObject~ typelib.

{{{var(list-of-signals)}}} is a list of signal specifications.
#+end_deffn

To then make instances of your custom GObject type, use ~make~.

** More Stuff
#+texinfo: @subsection On Guile to C Type Conversions
Guile-GI uses a rule system to convert Guile procedure arguments to C
types.  Typically these conversions between Guile and C types are
straightforward, but, some conversions are tricky and need additional
description.

#+texinfo: @subsubsection Strings
GObject libraries usually use UTF-8 encoding for their strings, while
Guile uses a different encoding internally for its strings.  Thus
every time a string is parameter is passed through to a C procedure, a
new UTF-8 copy of the Guile string is created.  The string is
automatically freed when no longer in use.

GObject has some procedures that deal with locale-encoded strings:
notably those procedures that deal with environment variables.
Guile-GI converts Guile strings to locale-encoded strings for those
procedures.  Note that this may throw an encoding error if the Guile
string cannot be represented in the current locale.

#+texinfo: @subsection C Arrays
There are many different types of C arrays, and the Guile types
expected for GObject procedures that C arrays varies depending on the
type required.

Typically, for simple C arrays of numerical types -- integers, floating
points, etc -- a Guile bytevector needs to be used.  For these
bytevectors, always use native-endianness.

For C arrays of GObject objects, structs, unions, flags, enums, and
GTypes, a /list/ is used instead of a bytevector.

If the C procedure expects a zero-terminated array, Guile-GI will
provide that automatically.  There is no need to add you own zero.

Some GObject procedures write output information into preallocated C
arrays.  For those procedures, the Guile caller will need to create
and pass in a bytevector of the appropriate size.

#+attr_texinfo: :options Warning
#+begin_quotation
It is best not to use any of GLib's ~Array~ and ~ByteArray~
procedures directly.  Since arrays get converted to bytevectors, these
procedures will likely fail to do anything sensible.
#+end_quotation

* Further Resources and Contact Info
Uh, I dunno.

Maybe the Guile mailing list?
* GNU Free Documentation License
:PROPERTIES:
:APPENDIX: t
:END:
#+texinfo: @include fdl-1.3.texi
* Index
:PROPERTIES:
:INDEX: cp
:END:
